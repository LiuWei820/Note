## 1.命令行窗口

![1662519021856](node.assets/1662519021856.png) 

在cmd命令行窗口里面创建文件夹hello

![1662519059196](node.assets/1662519059196.png) 

![1662519177737](node.assets/1662519177737.png) 

![1662519218601](node.assets/1662519218601.png) 

在文件夹里创建hello.txt，并输入文本内容

如果不是在hello文件夹的目录下打开hello.txt，则会报错

![1662519289387](node.assets/1662519289387.png) 

在hello文件夹下才可以打开hello.txt

![1662519347375](node.assets/1662519347375.png) 

如果hello.txt需要经常打开，但是又不想在hello文件夹下打开，就是那种无论在哪个目录下随时用随时打开的话，需要在环境变量中进行配置

![1662519489238](node.assets/1662519489238.png) 

![1662519549661](node.assets/1662519549661.png) 

![1662519631364](node.assets/1662519631364.png) 

![1662519703236](node.assets/1662519703236.png) 

想进入d盘的话就直接 d:

![1662519838556](node.assets/1662519838556.png) 

## 2.进程和线程

![1662520729337](node.assets/1662520729337.png) 

## 3.使用node执行js文件

![1662536851557](node.assets/1662536851557.png) 

![1662536882355](node.assets/1662536882355.png) 

## 4.fs文件系统模块

### 1.什么是fs文件系统模块

![1662540178331](node.assets/1662540178331.png) 

### 2.读取指定文件中的内容

#### 1.fs.readFile（）的语法格式

![1662541486574](node.assets/1662541486574.png) 

#### 2.fs.readFile（）的示例代码

### ![1662540916651](node.assets/1662540916651.png) 

#### ![1662540999267](node.assets/1662540999267.png)  

#### 3.判断文件是否读取成功 

![1662541945933](node.assets/1662541945933.png) 

![1662541988516](node.assets/1662541988516.png) 

### 3.向指定的文件写入内容

#### 1.fs.writeFile()方法

![1662542202348](node.assets/1662542202348.png) 

#### 2.fs.writeFile()的示例代码

![1662542615834](node.assets/1662542615834.png) 

![1662542638230](node.assets/1662542638230.png) 

![1662542810664](node.assets/1662542810664.png) 

### 4.练习---考试成绩整理

#### 1.需求

![1662543315185](node.assets/1662543315185.png) 

#### 2.核心步骤

![1662543350931](node.assets/1662543350931.png) 

![1662543916610](node.assets/1662543916610.png) 

![1662543957934](node.assets/1662543957934.png) 

![1662543975061](node.assets/1662543975061.png) 

### 5.路径动态拼接问题

![1662715350425](node.assets/1662715350425.png) 

![1662715678529](node.assets/1662715678529.png) 

![1662715930709](node.assets/1662715930709.png) 

#### 解决方法

![1662716032469](node.assets/1662716032469.png) 

![1662716230447](node.assets/1662716230447.png) 

![1662716287883](node.assets/1662716287883.png) 

![1662716503825](node.assets/1662716503825.png) 

## 5.path路径模块

### 1.什么是path模块

![1662716961056](node.assets/1662716961056.png) 

### 2.path.join()的语法格式

![1662717037622](node.assets/1662717037622.png) 

![1662717143660](node.assets/1662717143660.png) 

注意：今后凡是涉及到路径拼接的操作，都要使用path.join（）方法进行处理。不要直接使用+进行字符串的拼接

![1662717392530](node.assets/1662717392530.png) 

### 3.获取路径中的文件名

#### 1.pase.basename（）的语法格式

![1662717486746](node.assets/1662717486746.png) 

![1662717654668](node.assets/1662717654668.png) 

### 4.获取路径中的文件扩展名

![1662717718117](node.assets/1662717718117.png) 

#### 1.path.extname()代码示例

![1662717761178](node.assets/1662717761178.png) 

![1662717871859](node.assets/1662717871859.png) 

### 5.综合案例

#### 1.案例要实现的功能

![1662718033126](node.assets/1662718033126.png) 

#### 2.案例的实现步骤

![1662718153922](node.assets/1662718153922.png) 

##### 1.步骤1：导入需要的模块并创建正则表达式

![1662719053878](node.assets/1662719053878.png) 

##### 2.使用fs模块读取需要被处理的html文件

![1662719220926](node.assets/1662719220926.png)  

##### 3.自定义resolveCSS（）方法

![1662772732011](node.assets/1662772732011.png) 

##### 4.自定义resolveJS( )方法

![1662773047935](node.assets/1662773047935.png)  

##### 5.自定义resolveHTML方法( )

![1662773557202](node.assets/1662773557202.png)

#### 3.案例的两个注意点

![1662775322514](node.assets/1662775322514.png) 

##  6.http模块

### 1.什么是http模块

![1662775632717](node.assets/1662775632717.png) 

### 2.进一步理解http模块的作用

![1662775958469](node.assets/1662775958469.png) 

将自己的电脑变为服务器，装Apache软件

![1662775984615](node.assets/1662775984615.png) 

在自己的电脑上对外提供web服务

![1662776089187](node.assets/1662776089187.png) 

![1662776268984](node.assets/1662776268984.png) 

![1662776371016](node.assets/1662776371016.png) 

![1662776422786](node.assets/1662776422786.png) 

![1662776508124](node.assets/1662776508124.png) 

### 3.服务器相关的概念

#### 1.IP地址

![1662776765094](node.assets/1662776765094.png) 

![1662776945131](node.assets/1662776945131.png) 

![1662776817887](node.assets/1662776817887.png) 

![1662776870052](node.assets/1662776870052.png) 

#### 2.域名和域名服务器

![1662777163705](node.assets/1662777163705.png)  

#### 3.端口号

![1662777324670](node.assets/1662777324670.png) 

![1662777375163](node.assets/1662777375163.png) 

![1662777419905](node.assets/1662777419905.png) 

### 4.创建最基本的web服务器

#### 1.基本步骤

![1662777599643](node.assets/1662777599643.png)  

![1662777972076](node.assets/1662777972076.png) 

#### 2.req请求对象

![1662778259887](node.assets/1662778259887.png) 

![1662778817517](node.assets/1662778817517.png) 

如果想换成POST方法请求，则需要打开postman

![1662778871996](node.assets/1662778871996.png) 

![1662778896265](node.assets/1662778896265.png) 

![1662778930753](node.assets/1662778930753.png) 

![1662778976744](node.assets/1662778976744.png) 

#### 3.res响应对象

![1662779101560](node.assets/1662779101560.png) 

#### 4.解决中文乱码问题

![1662779375299](node.assets/1662779375299.png) 

![1662779322128](node.assets/1662779322128.png) 

### 5.根据不同的url响应不同的html内容

#### 1.核心实现步骤

![1662793581412](node.assets/1662793581412.png) 

#### 2.动态响应内容

![1662793691227](node.assets/1662793691227.png)  

![1662794038586](node.assets/1662794038586.png) 

### 6.实现clock时钟的web服务器

#### 1.核心思路

#### ![1662794302237](node.assets/1662794302237.png)  

#### 2.实现步骤

![1662794447825](node.assets/1662794447825.png) 

##### 步骤1--导入需要的模块

#### ![1662800153315](node.assets/1662800153315.png) 

#####  步骤2--创建基本的服务器

![1662800516907](node.assets/1662800516907.png) 

##### 步骤3--将资源的请求url地址映射为文件的存放路径

![1662800604097](node.assets/1662800604097.png) 

##### 步骤4--读取文件的内容并响应给客户端

![1662800785590](node.assets/1662800785590.png)  

##### 步骤5--优化资源的请求路径

![1662801236047](node.assets/1662801236047.png) 

## 7.模块化的基本概念

### 1.什么是模块化

![1662802021702](node.assets/1662802021702.png) 

#### 1.编程领域中的模块化

![1662806800472](node.assets/1662806800472.png) 

#### 2.模块化规范

![1662806878028](node.assets/1662806878028.png)

###  2.Node.js中的模块化

#### 1.模块的分类

![1662807078391](node.assets/1662807078391.png) 

#### 2.加载模块

![1662807339776](node.assets/1662807339776.png) 

注意：在使用require加载用户自定义模块期间，可以省略.js后缀名

### 3.Node.js中的模块作用域

#### 1.什么是模块作用域

![1662807617112](node.assets/1662807617112.png) 

#### 2.模块作用域的好处

![1662807728888](node.assets/1662807728888.png) 

![1662808024567](node.assets/1662808024567.png) 

### 4.向外共享模块作用域中的成员

![1662808187479](node.assets/1662808187479.png) 

#### 1.module.exports( )对象

![1662808322856](node.assets/1662808322856.png) 

![1662808634355](node.assets/1662808634355.png) 

![1662808689529](node.assets/1662808689529.png) 

 ![1662809521820](node.assets/1662809521820.png) 

#### 2.共享成员时的注意点

![1662809734432](node.assets/1662809734432.png) 

#### 3.exports对象

![1662809950918](node.assets/1662809950918.png) 

#### 4.exports和module.exports的使用误区

![1662811120082](node.assets/1662811120082.png) 

![1662811230736](node.assets/1662811230736.png) 

![1662811361702](node.assets/1662811361702.png) 

#### 5.Node.js中的模块化规范

![1662811534726](node.assets/1662811534726.png) 

## 8. 包

### 1.什么是包

![1662812008945](node.assets/1662812008945.png) 

#### 2.包的来源

![1662812138450](node.assets/1662812138450.png) 

#### 3.为什么需要包

![1662812205433](node.assets/1662812205433.png) 

#### 4.从哪里下载

![1662812393319](node.assets/1662812393319.png) 

#### 5.如何下载包

![1662812482153](node.assets/1662812482153.png) 

### 2.npm初体验

#### 1.格式化时间的传统做法

![1662812619514](node.assets/1662812619514.png) 

![1662895286438](node.assets/1662895286438.png) 

#### 2.格式化时间的高级做法

![1662895305188](node.assets/1662895305188.png) 

#### 3.项目中安装包的命令

![1662895440283](node.assets/1662895440283.png) 

![1662895551321](node.assets/1662895551321.png) 

#### 4.怎么查看包的用法（文档）

![1662895683868](node.assets/1662895683868.png) 

#### 5.初次装包后多了哪些文件

![1662896160807](node.assets/1662896160807.png) 

#### 6.安装指定版本的包

![1662896265250](node.assets/1662896265250.png) 

#### 7.包的语义化版本规范

![1662896479878](node.assets/1662896479878.png) 

### 3.npm与包

#### 1.包管理配置文件

![1662897104469](node.assets/1662897104469.png) 

#### 2.多人协作的问题

![1662897322302](node.assets/1662897322302.png) 

![1662897555026](node.assets/1662897555026.png)  

#### 3.快速创建package.json

![1662898343139](node.assets/1662898343139.png) 

#### 4.dependencies节点

![1662898675526](node.assets/1662898675526.png) 

#### 5.一次性安装所有的包

![1662898823725](node.assets/1662898823725.png) 

#### 6.一次性安装所有的包

![1662898974080](node.assets/1662898974080.png) 

#### 7.卸载包

![1662899040170](node.assets/1662899040170.png) 

#### 8.devDependencies节点

![1662899417179](node.assets/1662899417179.png) 

#### 9.解决npm下包慢的问题

##### 1.为什么下包速度慢

![1662900462336](node.assets/1662900462336.png) 

##### 2.淘宝NPM镜像服务器

![1662900576873](node.assets/1662900576873.png) 

##### 3.切换npm下包的镜像源

![1662900796603](node.assets/1662900796603.png) 

##### 4.nrm

![1662901002848](node.assets/1662901002848.png) 

![1662944254520](node.assets/1662944254520.png) 

#### 10.包的分类

##### 1.项目包

##### ![1662944461267](node.assets/1662944461267.png) 

##### 2.全局包

![1662944719715](node.assets/1662944719715.png) 

![1662945153017](node.assets/1662945153017.png) 

##### 3.i5ting_toc

![1662944875804](node.assets/1662944875804.png) 

##### 4.规范的包结构

![1662945470972](node.assets/1662945470972.png) 

#### 11.开发属于自己的包

##### 1.需要实现的功能

![1662945630733](node.assets/1662945630733.png) 

![1662945677687](node.assets/1662945677687.png) 

![1662945696998](node.assets/1662945696998.png) 

![1662945777228](node.assets/1662945777228.png) 

##### 2.初始化包的基本结构

![1662949098651](node.assets/1662949098651.png)   

![1662949316221](node.assets/1662949316221.png) 

##### 3.初始化package.json

![1662946342247](node.assets/1662946342247.png) 

##### 4.在index.js中定义格式化时间的方法

![1662949947523](node.assets/1662949947523.png) 

![1662950089304](node.assets/1662950089304.png) 

##### 5.在index.js中定义转义HTML的方法

![1662951024422](node.assets/1662951024422.png) 

![1662951108837](node.assets/1662951108837.png) 

##### 6.在index.js中定义还原HTML的方法

![1662951641786](node.assets/1662951641786.png) 

![1662951778421](node.assets/1662951778421.png) 

##### 7.将不同的功能进行模块化拆分

![1662951939396](node.assets/1662951939396.png) 

**dataFormats**

![1662952969925](node.assets/1662952969925.png) 

**htmlEscape.js**

![1662952867637](node.assets/1662952867637.png) 

**index.js**

![1662953059312](node.assets/1662953059312.png) 

**lww测试.js**

![1662953113482](node.assets/1662953113482.png) 

**输出结果**

![1662953143274](node.assets/1662953143274.png) 

##### 8.编写包的说明文档

![1662952807964](node.assets/1662952807964.png) 

![1662954076897](node.assets/1662954076897.png) 

#### 12.发布包

##### 1.注册npm账号

![1662954174160](node.assets/1662954174160.png) 

![1662966265229](node.assets/1662966265229.png) 

![1662966380037](node.assets/1662966380037.png) 

##### 2.登录npm账号

![1662966829601](node.assets/1662966829601.png) 

使用nrm ls查看所有的镜像源，再使用nrm use npm切换为npm的官方服务器，然后输入npm login

![1662967693940](node.assets/1662967693940.png) 

##### 3.把包发布到npm上

![1662967418177](node.assets/1662967418177.png) 

![1662968125503](node.assets/1662968125503.png) 

![1662967926608](node.assets/1662967926608.png)

![1662967961802](node.assets/1662967961802.png)  

#####  4.删除已经发布的包

![1662968433429](node.assets/1662968433429.png) 

![1662968845397](node.assets/1662968845397.png) 

## 9.模块的加载机制

### 1.优先从缓存中加载

![1662968976163](node.assets/1662968976163.png) 

在03.自定义模块里面console.log（'ok'）

![1662969089290](node.assets/1662969089290.png) 

在04.test里面require3次

![1662969156632](node.assets/1662969156632.png) 

但是终端里面只输出一次ok，原因是我们第一次require03模块时我们就已经把该模块进行缓存了  

![1662969190061](node.assets/1662969190061.png) 

### 2.内置模块的加载机制

![1662969795060](node.assets/1662969795060.png) 

### 3.自定义模块的加载机制

![1662970086352](node.assets/1662970086352.png) 

![1662970196185](node.assets/1662970196185.png) 

![1662970249603](node.assets/1662970249603.png) 

![1662970272568](node.assets/1662970272568.png) 

![1662970297506](node.assets/1662970297506.png) 

![1662970372495](node.assets/1662970372495.png) 

如果不写文件的扩展名就会按照确切的文件名进行加载

![1662970389503](node.assets/1662970389503.png) 

如果将test文件删除掉，则输出

![1662970538558](node.assets/1662970538558.png) 

如果将test.js文件也删除，则输出

![1662970597657](node.assets/1662970597657.png) 

如果test.json也删除，则输出

![1662970714434](node.assets/1662970714434.png) 

如果test.node也删除，则输出

![1662970799769](node.assets/1662970799769.png) 

### 4.第三方模块的加载机制

![1662972143483](node.assets/1662972143483.png) 

### 5.目录作为模块

![1662972203301](node.assets/1662972203301.png) 

![1662972286242](node.assets/1662972286242.png) ![1662972376933](node.assets/1662972376933.png) 

![1662972403284](node.assets/1662972403284.png) 

![1662972452714](node.assets/1662972452714.png) 

![1662972479426](node.assets/1662972479426.png) 

![1662972558123](node.assets/1662972558123.png) 

## 10.Express

### 1.Express简介

#### 1.什么是Express

![1662972742600](node.assets/1662972742600.png) 

#### 2.进一步理解Express

![1662972825922](node.assets/1662972825922.png) 

#### 3.Express能做什么

![1662973428974](node.assets/1662973428974.png) 

### 2.安装

![1662973514063](node.assets/1662973514063.png) 

![1662974110308](node.assets/1662974110308.png) 

### 3.创建基本的Web服务器

![1662973580028](node.assets/1662973580028.png) 

### 4.监听GET请求

![1662974607308](node.assets/1662974607308.png) 

### 5.监听POST请求

![1662975145666](node.assets/1662975145666.png) 

### 6. 把内容响应给客户端

![1662975120393](node.assets/1662975120393.png) 

![1662977669684](node.assets/1662977669684.png) 

打开postman

![1662977731455](node.assets/1662977731455.png) 

 ![1662977768973](node.assets/1662977768973.png) 

### 7.获取URL中携带的查询参数

![1662977891647](node.assets/1662977891647.png) 

![1662982357768](node.assets/1662982357768.png) 

![1662978691891](node.assets/1662978691891.png) 

### 8.获取URL中的动态参数

![1662981496160](node.assets/1662981496160.png) 

![1662982664167](node.assets/1662982664167.png) 

![1662982653855](node.assets/1662982653855.png) 

![1662982809295](node.assets/1662982809295.png) 

![1662982795955](node.assets/1662982795955.png) 

### 9.拖管静态资源

#### 1.express.static()

![1662982996593](node.assets/1662982996593.png) 

![1662983228407](node.assets/1662983228407.png) 

![1662983322498](node.assets/1662983322498.png) 

#### 2.拖管多个静态资源目录

![1662983521171](node.assets/1662983521171.png) 

#### 3.挂载路径前缀

![1662983831675](node.assets/1662983831675.png) 

## 11.nodemon

### 1.为什么要使用nodemon

![1662983966103](node.assets/1662983966103.png) 

### 2.安装

![1662984285997](node.assets/1662984285997.png)

### 3.使用nodemon

![1662984279210](node.assets/1662984279210.png) 

## 12.Express路由

### 1.路由的概念

#### 1.现实生活中的路由

**广义上来讲，路由就是映射关系**

![1662984893013](node.assets/1662984893013.png) 

#### 2.Express中的路由

![1662985205873](node.assets/1662985205873.png) 

#### 3.Express中的路由的例子

![1662985798211](node.assets/1662985798211.png) 

#### 4.路由匹配的过程

![1662985939036](node.assets/1662985939036.png) 

### 2.路由的使用

#### 1.最简单的用法

![1662986025472](node.assets/1662986025472.png) 

#### 2.模块化路由

![1662986446713](node.assets/1662986446713.png) 

#### 3.创建路由模块

![1662986865991](node.assets/1662986865991.png) 

#### 4.注册路由模块

![1662987448789](node.assets/1662987448789.png) 

注意：app.use的函数的作用，就是来注册全局中间件

![1662987629434](node.assets/1662987629434.png) 

![1662987745189](node.assets/1662987745189.png) 

![1662987799585](node.assets/1662987799585.png) 

#### 5.为路由模块添加前缀

![1662988131647](node.assets/1662988131647.png) 

![1662988163034](node.assets/1662988163034.png) 

![1662988237780](node.assets/1662988237780.png) 

![1662988260189](node.assets/1662988260189.png) 

## 13.Express中间件

### 1.中间件的概念

中间件，特指业务流程的中间处理环节

#### 1.现实生活中的例子

![1662988534057](node.assets/1662988534057.png) 

#### 2.Express中间件的调用流程

![1662988640427](node.assets/1662988640427.png) 

#### 3.Express中间件的格式

![1662988728250](node.assets/1662988728250.png) 

#### 4.next函数的作用

![1662988802142](node.assets/1662988802142.png) 

#### 5.定义中间件函数

![1663069693233](node.assets/1663069693233.png) 

#### 6.全局生效的中间价

![1663069661374](node.assets/1663069661374.png) 

#### 7.定义全局中间件的简化形式

![1663069967526](node.assets/1663069967526.png) 

### 2.中间件的作用

![1663070111638](node.assets/1663070111638.png) 

我们在上游的中间件中获取到请求到达服务器的时间，然后在下游可以进行调用

![1663070778659](node.assets/1663070778659.png) 

#### 1.定义多个全局中间件

![1663070919256](node.assets/1663070919256.png) 

![1663071446975](node.assets/1663071446975.png) 

![1663071457104](node.assets/1663071457104.png) 

#### 2.局部生效的中间件

![1663071755797](node.assets/1663071755797.png) 

![1663072616768](node.assets/1663072616768.png) 

![1663072650725](node.assets/1663072650725.png) 

![1663072660640](node.assets/1663072660640.png) 

![1663072679138](node.assets/1663072679138.png) 

![1663072707065](node.assets/1663072707065.png) 

#### 3.定义多个局部中间件

![1663072922261](node.assets/1663072922261.png) 

![1663073261348](node.assets/1663073261348.png) 

![1663073332865](node.assets/1663073332865.png) 

![1663073248244](node.assets/1663073248244.png) 

#### 4.了解中间件的5个使用注意项

![1663074613219](node.assets/1663074613219.png) 

### 3.中间件的分类

![1663074850339](node.assets/1663074850339.png) 

#### 1.应用级别的中间件

![1663121190175](node.assets/1663121190175.png) 

#### 2.路由级别的中间件

![1663121282529](node.assets/1663121282529.png) 

#### 3.错误级别的中间件

![1663122307420](node.assets/1663122307420.png) 

![1663121985579](node.assets/1663121985579.png) 

![1663122231911](node.assets/1663122231911.png) 

![1663122244531](node.assets/1663122244531.png) 

![1663122456980](node.assets/1663122456980.png) 

#### 4.Express的内置中间件

![1663122649952](node.assets/1663122649952.png) 

**express.json的案例**

![1663124177260](node.assets/1663124177260.png) 

![1663124206413](node.assets/1663124206413.png) 

**express.urlencoded的案例**

![1663124633651](node.assets/1663124633651.png) 

**extended: true**

![1663125497703](node.assets/1663125497703.png) 

![1663125513203](node.assets/1663125513203.png) 

**extended: false**

![1663125562821](node.assets/1663125562821.png) 

![1663125572877](node.assets/1663125572877.png) 

![1663124569709](node.assets/1663124569709.png) 

#### 5.第三方的中间件

![1663124979834](node.assets/1663124979834.png) 

![1663126027704](node.assets/1663126027704.png) 

![1663125992483](node.assets/1663125992483.png) 

### 4.自定义中间件

#### 1.需求描述与实现步骤

![1663126187896](node.assets/1663126187896.png) 

![1663468454302](node.assets/1663468454302.png) 

#### 2.监听req的data事件

![1663126724537](node.assets/1663126724537.png) 

![1663468741595](node.assets/1663468741595.png) 

#### 3.监听req的end事件

![1663126820704](node.assets/1663126820704.png) 

![1663469432762](node.assets/1663469432762.png) 

![1663469456081](node.assets/1663469456081.png) 

#### 4.使用querrystring模块解析请求体数据

![1663127022628](node.assets/1663127022628.png) 

![1663469717373](node.assets/1663469717373.png) 

![1663469741790](node.assets/1663469741790.png)  

#### 5.将解析出来的数据对象挂载为req.body

![1663127256628](node.assets/1663127256628.png) 

![1663470008187](node.assets/1663470008187.png) 

![1663470034897](node.assets/1663470034897.png)  

#### 6.将自定义中间件封装为模块

![1663466395957](node.assets/1663466395957.png) 

![1663470847784](node.assets/1663470847784.png) 

![1663470757441](node.assets/1663470757441.png) 

### 5.使用Express写接口

#### 1.创建基本的服务器

![1663471036502](node.assets/1663471036502.png) 

#### 2.创建API路由模块

![1663471752053](node.assets/1663471752053.png) 

#### 3.编写GET接口

![1663472186936](node.assets/1663472186936.png) 

![1663473693217](node.assets/1663473693217.png) 

![1663473729953](node.assets/1663473729953.png) 

#### 4.编写POST接口

![1663473883588](node.assets/1663473883588.png)  

![1663474475508](node.assets/1663474475508.png) 

![1663474399117](node.assets/1663474399117.png) 

### 6.CORS跨域资源共享

#### 1.接口的跨域问题

![1663474659035](node.assets/1663474659035.png) 

![1663475061922](node.assets/1663475061922.png) 

![1663484058819](node.assets/1663484058819.png) 

![1663484012514](node.assets/1663484012514.png) 

#### 2.使用CORS中间件解决跨域问题

![1663475163915](node.assets/1663475163915.png) 

![1663484112490](node.assets/1663484112490.png) 

![1663484155071](node.assets/1663484155071.png) 

![1663484178131](node.assets/1663484178131.png) 

#### 3.什么是CORS

![1663475407128](node.assets/1663475407128.png) 

#### 4.CORS的注意事项

![1663475505964](node.assets/1663475505964.png) 

####  5.CORS响应头部-Access-Control-Allow-Origin

![1663484363561](node.assets/1663484363561.png) 

![1663484411798](node.assets/1663484411798.png) 

#### 6.CORS响应头部-Access-Control-Allow-Headers

![1663484542474](node.assets/1663484542474.png) 

#### 7.CORS响应头部-Access-Control-Allow-Methods

![1663484647276](node.assets/1663484647276.png) 

#### 8.CORS请求的分类

![1663484708549](node.assets/1663484708549.png) 

#####  简单请求

![1663484757265](node.assets/1663484757265.png) 

##### 预检请求

![1663484854742](node.assets/1663484854742.png) 

##### 区别

![1663484926649](node.assets/1663484926649.png)  

![1663485585109](node.assets/1663485585109.png) 

![1663485625021](node.assets/1663485625021.png) 

![1663485561116](node.assets/1663485561116.png) 

### 7.JSONP接口

#### 1.回顾JSONP的概念与特点

![1663488551134](node.assets/1663488551134.png) 

#### 2.创建JSONP接口的注意事项

![1663488619939](node.assets/1663488619939.png) 

#### 3.实现JSONP接口的步骤

![1663488900519](node.assets/1663488900519.png) 

![1663488950519](node.assets/1663488950519.png) 

#### 4.在网页中使用JQuery发起JSONP请求

![1663489607706](node.assets/1663489607706.png) 

![1663490089568](node.assets/1663490089568.png) 

![1663490156268](node.assets/1663490156268.png) 

![1663490179591](node.assets/1663490179591.png) 

## 14.数据库

### 1.基本概念

#### 1.什么是数据库

![1663490514317](node.assets/1663490514317.png)  

#### 2.常见的数据库及分类

![1663490684994](node.assets/1663490684994.png) 

![1663490755512](node.assets/1663490755512.png) 

#### 3.传统型数据库的数据组织结构

![1663490881323](node.assets/1663490881323.png) 

**Excel的数据组织结构**

![1663491032574](node.assets/1663491032574.png) 

![1663491145648](node.assets/1663491145648.png) 

#### 4.实际开发中库、表、行、字段的关系

![1663491497451](node.assets/1663491497451.png) 

### 2.安装并配置MySQL

#### 1.需要安装的相关软件

![1663491615115](node.assets/1663491615115.png) 

![1663501801660](node.assets/1663501801660.png) 

### 3.使用MySQL   Workbench管理数据库

![1663502523060](node.assets/1663502523060.png) 

#### 1.了解主界面的组成部分

![1663502925802](node.assets/1663502925802.png)  

![1663503054705](node.assets/1663503054705.png) 

#### 2.创建数据库

![1663503218827](node.assets/1663503218827.png) 

![1663503304805](node.assets/1663503304805.png) 

#### 3.创建数据表

![1663503582503](node.assets/1663503582503.png)

![1663503868971](node.assets/1663503868971.png) 

![1663504077308](node.assets/1663504077308.png) 

![1663504137833](node.assets/1663504137833.png) 

![1663504361305](node.assets/1663504361305.png) 

![1663504462089](node.assets/1663504462089.png) 

#### 4.向表中写入数据

![1663504728718](node.assets/1663504728718.png) 

![1663504771784](node.assets/1663504771784.png) 

### 4.使用SQL管理数据库

#### 1.什么是数据库

![1663505057520](node.assets/1663505057520.png) 

#### 2.SQL能做什么

![1663505113673](node.assets/1663505113673.png) 

#### 3.SQL的学习目标

![1663505151756](node.assets/1663505151756.png) 

### 5.SQL的SELECT语句

#### 1.语法

![1663505270953](node.assets/1663505270953.png) 

#### 2.SELECT   * 示例

![1663505538425](node.assets/1663505538425.png) 

![1663506147245](node.assets/1663506147245.png) 

#### 3.SELECT   列名称  示例

![1663505408693](node.assets/1663505408693.png) 

![1663506177248](node.assets/1663506177248.png) 

### 6.SQL的INSERT  INTO语句

#### 1.语法

![1663506270497](node.assets/1663506270497.png) 

#### 2.示例

![1663506310684](node.assets/1663506310684.png) 

![1663506491668](node.assets/1663506491668.png) 

### 7.SQL的UPDATE语句

#### 1.语法

![1663506593815](node.assets/1663506593815.png) 

#### 2.示例----更新某一行中的一个列

![1663507397549](node.assets/1663507397549.png) 

#### 3.示例----更新某一行中的若干列

![1663507493528](node.assets/1663507493528.png) 

![1663507563991](node.assets/1663507563991.png) 

### 8.SQL的DELETE语句

#### 1.语法

![1663507643124](node.assets/1663507643124.png) 

![1663507761713](node.assets/1663507761713.png) 

### 9.SQL的WHERE子句

![1663549492663](node.assets/1663549492663.png) 

####  1.运算符

![1663549532251](node.assets/1663549532251.png) 

#### 2.子句示例 

![1663549571943](node.assets/1663549571943.png)

### 10.SQL的AND和OR运算符

![1663549802427](node.assets/1663549802427.png) 

 ![1663549829663](node.assets/1663549829663.png) 

![1663549852988](node.assets/1663549852988.png) 

### 11.SQL的      ORDER  BY   子句

![1663550249034](node.assets/1663550249034.png) 

![1663550335265](node.assets/1663550335265.png) 

![1663550357676](node.assets/1663550357676.png) 

**多重排序**

![1663550455242](node.assets/1663550455242.png) 

### 12.SQL的 COUNT（*）函数

![1663551255085](node.assets/1663551255085.png) 

## 15.在项目中操作MySQL

### 1.在项目中操作MySQL的步骤

![1663552493409](node.assets/1663552493409.png) 

### 2.安装与配置MySQL模块

![1663552576579](node.assets/1663552576579.png) 

![1663552795740](node.assets/1663552795740.png)  

### 3.测试mysql模块能否正常工作

![1663553361750](node.assets/1663553361750.png) 

## 16.使用MySQL模块操作操作MySQL数据库

### 1.查询数据

![1663553856256](node.assets/1663553856256.png) 

![1663597904619](1663597904619.png) 

### 2.插入数据

![1663597927454](1663597927454.png)

![1663597996505](node.assets/1663597996505.png) 

**快捷方式**

![1663598016083](node.assets/1663598016083.png) 

### 3.更改新数据

![1663598071288](node.assets/1663598071288.png) 

**第一个占位符的值是user.username，第二个占位符的值是user.password，第三个占位符的值是user.id**

![1663598093496](node.assets/1663598093496.png) 

**更新数据的便捷方式**

![1663598112877](node.assets/1663598112877.png) 

**执行了update语句之后，执行的结果也是一个对象，可以通过affectedRows判断是否更新成功**

### 4.删除数据

![1663598134156](node.assets/1663598134156.png)  

![1663598149529](node.assets/1663598149529.png) 

### 5.标记删除

![1663598166617](node.assets/1663598166617.png) 

![1663598183145](node.assets/1663598183145.png) 

## 17.前后端的身份认证

### 1.服务端渲染的Web开发模式

![1663598242138](node.assets/1663598242138.png) 

### 2.服务端渲染的优缺点

![1663598252321](node.assets/1663598252321.png)  

### 3.前后端分离的Web开发模式

![1663598495758](node.assets/1663598495758.png)  

### 4.前后端分离的优缺点

![1663598511258](node.assets/1663598511258.png) 

### 5.如何选择Web开发模式

![1663598348626](node.assets/1663598348626.png) 

### 6.身份认证

#### 1.什么是身份认证

![1663598539129](node.assets/1663598539129.png) 

#### 2.为什么需要身份认证

![1663598552093](node.assets/1663598552093.png) 

####  3. 不同开发模式下的身份认证

![1663598576728](node.assets/1663598576728.png) 

### 7.Session认证机制

#### 1.HTTP协议的无状态性

![1663598617117](node.assets/1663598617117.png) 

#### 2.如何突破HTTP无状态的限制

![1663598644957](node.assets/1663598644957.png) 

#### 3.什么是Cookie

![1663598684022](node.assets/1663598684022.png) 

![1663598707195](node.assets/1663598707195.png)

![1663598733590](node.assets/1663598733590.png)

####  4.cookie在身份认证中的作用

 ![1663598770320](node.assets/1663598770320.png)

#### 5.cookie不具有安全性

![1663598788751](node.assets/1663598788751.png)

#### 6.提高身份认证的安全性

#### ![1663598806386](node.assets/1663598806386.png)

#### 7.Session的工作原理

![1663598819788](node.assets/1663598819788.png) 

## 18.在Express中使用Session认证

### 1.安装express-session中间件

![1663598835301](node.assets/1663598835301.png)

### 2.配置express-session中间件

![1663598850187](node.assets/1663598850187.png)

![1663598865707](node.assets/1663598865707.png) 

### 3.向Session中存数据

![1663598879094](node.assets/1663598879094.png)  

![1663598895884](node.assets/1663598895884.png) 

### 4.从session中取数据

![1663598910823](node.assets/1663598910823.png) 

### 5.清空session

![1663598926379](node.assets/1663598926379.png)  



​	 











