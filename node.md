## 1.命令行窗口

![1662519021856](node.assets/1662519021856.png) 

在cmd命令行窗口里面创建文件夹hello

![1662519059196](node.assets/1662519059196.png) 

![1662519177737](node.assets/1662519177737.png) 

![1662519218601](node.assets/1662519218601.png) 

在文件夹里创建hello.txt，并输入文本内容

如果不是在hello文件夹的目录下打开hello.txt，则会报错

![1662519289387](node.assets/1662519289387.png) 

在hello文件夹下才可以打开hello.txt

![1662519347375](node.assets/1662519347375.png) 

如果hello.txt需要经常打开，但是又不想在hello文件夹下打开，就是那种无论在哪个目录下随时用随时打开的话，需要在环境变量中进行配置

![1662519489238](node.assets/1662519489238.png) 

![1662519549661](node.assets/1662519549661.png) 

![1662519631364](node.assets/1662519631364.png) 

![1662519703236](node.assets/1662519703236.png) 

想进入d盘的话就直接 d:

![1662519838556](node.assets/1662519838556.png) 

## 2.进程和线程

![1662520729337](node.assets/1662520729337.png) 

## 3.使用node执行js文件

![1662536851557](node.assets/1662536851557.png) 

![1662536882355](node.assets/1662536882355.png) 

## 4.fs文件系统模块

### 1.什么是fs文件系统模块

![1662540178331](node.assets/1662540178331.png) 

### 2.读取指定文件中的内容

#### 1.fs.readFile（）的语法格式

![1662541486574](node.assets/1662541486574.png) 

#### 2.fs.readFile（）的示例代码

### ![1662540916651](node.assets/1662540916651.png) 

#### ![1662540999267](node.assets/1662540999267.png)  

#### 3.判断文件是否读取成功 

![1662541945933](node.assets/1662541945933.png) 

![1662541988516](node.assets/1662541988516.png) 

### 3.向指定的文件写入内容

#### 1.fs.writeFile()方法

![1662542202348](node.assets/1662542202348.png) 

#### 2.fs.writeFile()的示例代码

![1662542615834](node.assets/1662542615834.png) 

![1662542638230](node.assets/1662542638230.png) 

![1662542810664](node.assets/1662542810664.png) 

### 4.练习---考试成绩整理

#### 1.需求

![1662543315185](node.assets/1662543315185.png) 

#### 2.核心步骤

![1662543350931](node.assets/1662543350931.png) 

![1662543916610](node.assets/1662543916610.png) 

![1662543957934](node.assets/1662543957934.png) 

![1662543975061](node.assets/1662543975061.png) 

### 5.路径动态拼接问题

![1662715350425](node.assets/1662715350425.png) 

![1662715678529](node.assets/1662715678529.png) 

![1662715930709](node.assets/1662715930709.png) 

#### 解决方法

![1662716032469](node.assets/1662716032469.png) 

![1662716230447](node.assets/1662716230447.png) 

![1662716287883](node.assets/1662716287883.png) 

![1662716503825](node.assets/1662716503825.png) 

## 5.path路径模块

### 1.什么是path模块

![1662716961056](node.assets/1662716961056.png) 

### 2.path.join()的语法格式

![1662717037622](node.assets/1662717037622.png) 

![1662717143660](node.assets/1662717143660.png) 

注意：今后凡是涉及到路径拼接的操作，都要使用path.join（）方法进行处理。不要直接使用+进行字符串的拼接

![1662717392530](node.assets/1662717392530.png) 

### 3.获取路径中的文件名

#### 1.pase.basename（）的语法格式

![1662717486746](node.assets/1662717486746.png) 

![1662717654668](node.assets/1662717654668.png) 

### 4.获取路径中的文件扩展名

![1662717718117](node.assets/1662717718117.png) 

#### 1.path.extname()代码示例

![1662717761178](node.assets/1662717761178.png) 

![1662717871859](node.assets/1662717871859.png) 

### 5.综合案例

#### 1.案例要实现的功能

![1662718033126](node.assets/1662718033126.png) 

#### 2.案例的实现步骤

![1662718153922](node.assets/1662718153922.png) 

##### 1.步骤1：导入需要的模块并创建正则表达式

![1662719053878](node.assets/1662719053878.png) 

##### 2.使用fs模块读取需要被处理的html文件

![1662719220926](node.assets/1662719220926.png)  

##### 3.自定义resolveCSS（）方法

![1662772732011](node.assets/1662772732011.png) 

##### 4.自定义resolveJS( )方法

![1662773047935](node.assets/1662773047935.png)  

##### 5.自定义resolveHTML方法( )

![1662773557202](node.assets/1662773557202.png)

#### 3.案例的两个注意点

![1662775322514](node.assets/1662775322514.png) 

##  6.http模块

### 1.什么是http模块

![1662775632717](node.assets/1662775632717.png) 

### 2.进一步理解http模块的作用

![1662775958469](node.assets/1662775958469.png) 

将自己的电脑变为服务器，装Apache软件

![1662775984615](node.assets/1662775984615.png) 

在自己的电脑上对外提供web服务

![1662776089187](node.assets/1662776089187.png) 

![1662776268984](node.assets/1662776268984.png) 

![1662776371016](node.assets/1662776371016.png) 

![1662776422786](node.assets/1662776422786.png) 

![1662776508124](node.assets/1662776508124.png) 

### 3.服务器相关的概念

#### 1.IP地址

![1662776765094](node.assets/1662776765094.png) 

![1662776945131](node.assets/1662776945131.png) 

![1662776817887](node.assets/1662776817887.png) 

![1662776870052](node.assets/1662776870052.png) 

#### 2.域名和域名服务器

![1662777163705](node.assets/1662777163705.png)  

#### 3.端口号

![1662777324670](node.assets/1662777324670.png) 

![1662777375163](node.assets/1662777375163.png) 

![1662777419905](node.assets/1662777419905.png) 

### 4.创建最基本的web服务器

#### 1.基本步骤

![1662777599643](node.assets/1662777599643.png)  

![1662777972076](node.assets/1662777972076.png) 

#### 2.req请求对象

![1662778259887](node.assets/1662778259887.png) 

![1662778817517](node.assets/1662778817517.png) 

如果想换成POST方法请求，则需要打开postman

![1662778871996](node.assets/1662778871996.png) 

![1662778896265](node.assets/1662778896265.png) 

![1662778930753](node.assets/1662778930753.png) 

![1662778976744](node.assets/1662778976744.png) 

#### 3.res响应对象

![1662779101560](node.assets/1662779101560.png) 

#### 4.解决中文乱码问题

![1662779375299](node.assets/1662779375299.png) 

![1662779322128](node.assets/1662779322128.png) 

### 5.根据不同的url响应不同的html内容

#### 1.核心实现步骤

![1662793581412](node.assets/1662793581412.png) 

#### 2.动态响应内容

![1662793691227](node.assets/1662793691227.png)  

![1662794038586](node.assets/1662794038586.png) 

### 6.实现clock时钟的web服务器

#### 1.核心思路

#### ![1662794302237](node.assets/1662794302237.png)  

#### 2.实现步骤

![1662794447825](node.assets/1662794447825.png) 

##### 步骤1--导入需要的模块

#### ![1662800153315](node.assets/1662800153315.png) 

#####  步骤2--创建基本的服务器

![1662800516907](node.assets/1662800516907.png) 

##### 步骤3--将资源的请求url地址映射为文件的存放路径

![1662800604097](node.assets/1662800604097.png) 

##### 步骤4--读取文件的内容并响应给客户端

![1662800785590](node.assets/1662800785590.png)  

##### 步骤5--优化资源的请求路径

![1662801236047](node.assets/1662801236047.png) 

## 7.模块化的基本概念

### 1.什么是模块化

![1662802021702](node.assets/1662802021702.png) 

#### 1.编程领域中的模块化

![1662806800472](node.assets/1662806800472.png) 

#### 2.模块化规范

![1662806878028](node.assets/1662806878028.png)

###  2.Node.js中的模块化

#### 1.模块的分类

![1662807078391](node.assets/1662807078391.png) 

#### 2.加载模块

![1662807339776](node.assets/1662807339776.png) 

注意：在使用require加载用户自定义模块期间，可以省略.js后缀名

### 3.Node.js中的模块作用域

#### 1.什么是模块作用域

![1662807617112](node.assets/1662807617112.png) 

#### 2.模块作用域的好处

![1662807728888](node.assets/1662807728888.png) 

![1662808024567](node.assets/1662808024567.png) 

### 4.向外共享模块作用域中的成员

![1662808187479](node.assets/1662808187479.png) 

#### 1.module.exports( )对象

![1662808322856](node.assets/1662808322856.png) 

![1662808634355](node.assets/1662808634355.png) 

![1662808689529](node.assets/1662808689529.png) 

 ![1662809521820](node.assets/1662809521820.png) 

#### 2.共享成员时的注意点

![1662809734432](node.assets/1662809734432.png) 

#### 3.exports对象

![1662809950918](node.assets/1662809950918.png) 

#### 4.exports和module.exports的使用误区

![1662811120082](node.assets/1662811120082.png) 

![1662811230736](node.assets/1662811230736.png) 

![1662811361702](node.assets/1662811361702.png) 

#### 5.Node.js中的模块化规范

![1662811534726](node.assets/1662811534726.png) 

## 8. 包

### 1.什么是包

![1662812008945](node.assets/1662812008945.png) 

#### 2.包的来源

![1662812138450](node.assets/1662812138450.png) 

#### 3.为什么需要包

![1662812205433](node.assets/1662812205433.png) 

#### 4.从哪里下载

![1662812393319](node.assets/1662812393319.png) 

#### 5.如何下载包

![1662812482153](node.assets/1662812482153.png) 

### 2.npm初体验

#### 1.格式化时间的传统做法

![1662812619514](node.assets/1662812619514.png) 

















​	